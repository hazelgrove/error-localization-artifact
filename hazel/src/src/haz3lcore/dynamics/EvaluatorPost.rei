/**
  Postprocessing of the evaluation result.

  NOTE: Currently disabled due to exponential blow-up in certain situations, but
        leaving here for now until we can fully investigate.

  This has two functions:
    - Match the evaluation result generated by evaluation with substitution.
      This means to continue evaluation within expressions for which evaluation
      has not reached (e.g., lambda expression bodies, unmatched case and let
      expression bodies), by looking up bound variables and assigning hole
      environments.
    - Number holes and generate a HoleInstanceInfo.t that holds information
      about all unique hole instances in the result.

  The postprocessing steps are partially memoized by environments. (Only
  memoized among hole instances which share the same environment.)

  Algorithmically, this algorithm begins in the evaluated region of the
  evaluation result inside the "evaluation boundary" (pp_eval), and continues
  to the region outside the evaluation boundary (pp_uneval).
 */

/**
  Errors related to EvalPostprocess.postprocess

  Postprocessing invalid cases: Evaluation boundary is abbreviated as "EB". "In
  closure" and "outside closure" correspond to "outside the EB" and "inside the
  EB," respectively.

  The following errors are used to indicate an invalid case DURING
  postprocessing:

    - ClosureInsideClosure: an evaluated expression outside the EB
    - BoundVarOutsideClosure: an un-looked-up (unevaluated) variable inside the EB
    - UnevalOutsideClosure: non-variable unevaluated expression inside the EB
    - InvalidClosureBody: closures currently only make sense storing the
      following expression types:
      - Hole expressions
      - Lambda abstractions
      - Let/case with a pattern match failure

   The following errors are used to indicate an invalid case AFTER postprocessing.
   After postprocessing, closures around lambda abstractions, let expressions, and
   case expressions should be removed, and all hole expressions should be wrapped
   in a closure.

    - PostprocessedNoneHoleInClosure
    - PostprocessedHoleOutsideClosure
   */
[@deriving sexp]
type error =
  | ClosureInsideClosure
  | FixFOutsideClosureEnv
  | UnevalOutsideClosure
  | InvalidClosureBody
  | PostprocessedNonHoleInClosure
  | PostprocessedHoleOutsideClosure;

[@deriving sexp]
exception Exception(error);

/**
  Postprocessing driver.

  Note: The top-level expression is wrapped in a non-empty hole, this is a
  clean way of noting holes that lie directly in the result.

  See also HoleInstanceInfo.rei/HoleInstanceInfo_.rei.
 */
let postprocess:
  (DHExp.t, EnvironmentIdGen.t) =>
  ((HoleInstanceInfo.t, DHExp.t), EnvironmentIdGen.t);
